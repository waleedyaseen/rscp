package me.waliedyassen.rscp

import com.github.michaelbull.logging.InlineLogger
import me.waliedyassen.rscp.format.ConstantFileType
import me.waliedyassen.rscp.format.FileType
import me.waliedyassen.rscp.format.ParseResult
import me.waliedyassen.rscp.format.config.Config
import me.waliedyassen.rscp.parser.Diagnostic
import me.waliedyassen.rscp.parser.DiagnosticKind
import me.waliedyassen.rscp.parser.Reference
import me.waliedyassen.rscp.parser.SemanticInfo
import me.waliedyassen.rscp.parser.Span
import me.waliedyassen.rscp.symbol.SymbolTable
import me.waliedyassen.rscp.symbol.SymbolType
import java.io.File
import kotlin.reflect.KMutableProperty0

class Compiler(private val extractMode: ExtractMode) {

    /**
     * The symbol table of the compiler.
     */
    val sym = SymbolTable()

    /**
     * A list of all the tracked semantic information so far.
     */
    val semanticInfo = mutableListOf<SemanticInfo>()

    /**
     * A list of all the diagnostics generated by the compiler so far.
     */
    val diagnostics = mutableListOf<Diagnostic>()

    /**
     * Read all the symbols from the specified [directory] and store them in the symbol table.
     */
    fun readSymbols(directory: File) {
        check(directory.exists()) { "The specified symbols directory does not exist" }
        directory.listFiles()?.forEach { file ->
            val result = SYMBOL_FILE_REGEX.matchEntire(file.name) ?: return@forEach
            val literal = result.groupValues[1]
            val type = SymbolType.lookup(literal)
            sym.read(type, file)
            logger.info { "Parsed a total of ${sym.lookupList(type).symbols.size} '$literal' symbol entries" }
        }
    }

    /**
     * Write all the symbols in the symbol table to the specified [directory].
     */
    fun writeSymbols(directory: File) {
        for (type in SymbolType.values) {
            val list = sym.lookupList(type)
            if (list.modified) {
                logger.info { "Writing symbol table changes for '${type.literal}'" }
                sym.write(type, directory.resolve("${type.literal}.sym"))
            }
        }
    }

    /**
     * Compile all the configs within the specified [directory].
     */
    fun compileDirectory(directory: File): List<SymbolContributor> {
        logger.info { "Compiling configs from directory $directory" }
        val handlers = directory.walkTopDown()
            .mapNotNull { file -> FileType.find(file.extension)?.let { type -> file to type } }

        val (otherHandlers, constantHandlers) = handlers.partition { it.second !is ConstantFileType }
        val otherResults = mutableListOf<ParseResult<*>>()
        val constantResults = mutableListOf<ParseResult<*>>()
        // TODO(Walied): Right now constants are evaluated at parse time, so we need to parse and register all
        // of the constants before we parse configs.
        for ((file, handler) in constantHandlers) {
            val parser = handler.createParser(this, file, extractMode == ExtractMode.SemInfo)
            constantResults += handler.parse(parser)
            if (extractMode == ExtractMode.SemInfo) {
                semanticInfo += parser.semInfo
            }
        }
        val constants = constantResults.flatMap { it.units }
        generateSymbols(constantResults.flatMap { it.units })
        for ((file, handler) in otherHandlers) {
            val parser = handler.createParser(this, file, extractMode == ExtractMode.SemInfo)
            otherResults += handler.parse(parser)
            if (extractMode == ExtractMode.SemInfo) {
                semanticInfo += parser.semInfo
            }
        }
        val others = otherResults.flatMap { it.units }
        generateSymbols(otherResults.flatMap { it.units })
        otherResults.forEach { it.runValidateCode() }
        return others + constants
    }

    private fun <T : SymbolContributor> ParseResult<T>.runValidateCode() {
        type.validate(this@Compiler, this)
    }

    /**
     * Generate the symbol table information for the specified list of [Config].
     */
    private fun generateSymbols(contributors: List<SymbolContributor>) {
        contributors.forEach { contributor -> contributor.contributeSymbols(sym) }
    }

    /**
     * Compile the specified config [file].
     */
    fun compileFile(file: File): List<SymbolContributor> {
        val fileType = FileType.find(file.extension) ?: return emptyList()
        val parser = fileType.createParser(this, file, extractMode == ExtractMode.SemInfo)
        val result = fileType.parse(parser)
        if (extractMode == ExtractMode.SemInfo) {
            semanticInfo += parser.semInfo
        }
        generateSymbols(result.units)
        result.runValidateCode()
        return result.units
    }

    /**
     * Generate byte code for the specified list of [generators] then write the generated byte code
     * to the disk.
     */
    fun generateCode(generators: List<CodeGenerator>, directory: File) {
        if (generators.isEmpty()) return
        check(directory.exists() || directory.mkdirs()) { "Failed to create the output directory '${directory}'" }
        logger.info { "Writing ${generators.size} configs to $directory" }
        generators.forEach { generator -> generator.generateCode(directory, sym) }
    }

    /**
     * Add an error diagnostic to the generated diagnostic list.
     */
    fun addError(span: Span, message: String) {
        addDiagnostic(DiagnosticKind.Error, span, message)
    }

    /**
     * Add a diagnostic to the generated diagnostics list.
     */
    private fun addDiagnostic(kind: DiagnosticKind, span: Span, message: String) {
        diagnostics += Diagnostic(kind, span, message)
    }


    /**
     * Attempt to resolve the specified [reference] from the symbol table and return
     * the symbol id if the resolve was successful otherwise -1.
     */
    fun resolveReference(reference: Reference?, permitNulls: Boolean = true): Int {
        if (reference == null) {
            return -1
        }
        val symbol = sym.lookupSymbol(reference.type, reference.name)
        if (reference.name == "null") {
            if (!permitNulls) {
                addError(reference.span, "Null values are not permitted in here")
            }
            return -1
        }
        if (symbol == null) {
            val message = "Unresolved reference to '${reference.name}' of type '${reference.type.literal}'"
            addError(reference.span, message)
            return -1
        }
        return symbol.id

    }


    /**
     * Attempt to resolve the specified [reference] from the symbol table and return
     * the symbol id if the resolve was successful otherwise -1.
     */
    fun resolveReference(reference: KMutableProperty0<Any?>, permitNulls: Boolean = true) {
        val current = reference()
        if (current == null) {
            reference.set(-1)
        } else if (current is Reference) {
            reference.set(resolveReference(current, permitNulls))
        }
    }


    /**
     * Attempt to resolve the specified [reference] from the symbol table and return
     * the symbol id if the resolve was successful otherwise -1.
     */
    @JvmName("resolveReference1")
    fun resolveReference(reference: KMutableProperty0<Any>, permitNulls: Boolean = true) {
        val current = reference()
        if (current is Reference) {
            reference.set(resolveReference(current, permitNulls))
        }
    }

    companion object {
        private val logger = InlineLogger()
        private val SYMBOL_FILE_REGEX = Regex("(\\w+)\\.sym")
    }
}